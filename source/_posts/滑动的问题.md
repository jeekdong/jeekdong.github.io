---
title: 微信内置浏览器'滑动'的问题
date: 2018-10-09 17:30:54
tags:
---

## 背景
前面在写一个移动端的页面，竖屏轮播的效果，上滑下滑可以上翻下翻

但是在微信的内置浏览器遇到了一个问题，微信内置浏览器你在页面下滑会显示“该网页有XXX提供”，这与我们网页的下滑操作冲突，直接导致在网页下滑根本无法向上翻页。其实在chrome手机浏览器也有类似的小问题，下滑会有一定几率被浏览器当做刷新的行为。

## 分析&&解决
既然了解了问题的表现，就可以简单分析问题的原因，下滑首先就是联想到就是`touch`事件，当我们touch屏幕下滑发生了浏览器的默认行为，于是我们在文档元素中直接禁用掉`touchstart`事件的默认行为，如下，需要注意的是`addEventListener`的第三个参数必须是指定`{passive: false}`，否则是无法去除touch事件的默认行为，具体原因我们放在最后面讲。

```javascript
    document.querySelector('body').addEventListener('touchstart', function(e) {
        e.preventDefault();
    }, {passive: false})
```

总之我们现在去除了touchstart事件的默认行为。实际在微信内置浏览器中的表现也非常好，确实下滑不会再出现“该网页有XXX提供”。而且网页也可以正常上滑下滑，但是网页的链接没法点击了(゜-゜)

> 为什么在文档元素取消touchstart事件默认事件依然可以下滑，但是无法按钮无法点击呢？

具体来说如果一个事件有默认的触发动作，那么要等到冒泡过程执行完毕，才会执行（没有被中途阻止的话）

1. 对于`touchstart`事件来说他是可以冒泡的
2. 当我们点击`a`标签，事件的触发顺序是 `a --> div --> document`
3. 在`document`的`touchstart`事件处理程序中执行了`event.preventDefault()`因此链接的默认行为被阻止了

解决方法很简单，一种是在`event.preventDefault()`前判断`event.target`对象是不是a元素，另外一种是给链接单独加一个`touchstart`事件处理程序跳转链接

对于网页的轮播效果，我使用的是`zepto.fullpage`，查看源码可以发现它上滑/下滑是采用`touchstart`事件和`touchend`事件结合判断的，这是不属于事件的默认行为不会被阻止

```javascript
    $this.on('touchstart', function(e) {
        if (!that.status) {return 1;}
        //e.preventDefault();
        if (that.movingFlag) {
            return 0;
        }

        that.startX = e.targetTouches[0].pageX;
        that.startY = e.targetTouches[0].pageY;
    });
    $this.on('touchend', function(e) {
        if (!that.status) {return 1;}
        //e.preventDefault();
        if (that.movingFlag) {
            return 0;
        }

        var sub = that.o.dir === 'v' ? (e.changedTouches[0].pageY - that.startY) /
                              that.height : (e.changedTouches[0].pageX - that.startX) / that.width;
        var der = (sub > that.o.der || sub < -that.o.der) ? sub > 0 ? -1 : 1 : 0;

        that.moveTo(that.curIndex + der, true);
    });
```

## passive
最后我们讲一下为什么要加上passive, 在浏览器中它是无法预知一个监听器是会不会调用`preventDefault()`，因此它需要等待事件监听器全部执行完，再去执行默认行为，而等待监听器的执行需要时间，往往会导致页面的卡顿

chrome做了一个统计：

> For instance, in Chrome for Android 80% of the touch events that block scrolling never actually prevent it. 10% of these events add more than 100ms of delay to the start of scrolling, and a catastrophic delay of at least 500ms occurs in 1% of scrolls.

在 Android 版 Chrome 浏览器的 `touch` 事件监听器的页面中，80% 的页面都不会调用 `preventDefault` 函数来阻止事件的默认行为

因此在最新的DOM规范中`addEventListener`第三个参数改为了对象：`target.addEventListener(type, listener[, options]);`，这时候我们可以在第三个参数中传入`passive: true`来告诉浏览器不会取消事件的默认行为，绝大多数元素默认`passive`是false，对于文档级别元素默认`passive`为true。[参考](https://www.chromestatus.com/features/5093566007214080)

对于不支持的浏览器也有一个非常有用的渐进增强的方法:

```javascript
// Test via a getter in the options object to see 
// if the passive property is accessed
var supportsPassive = false;
try {
  var opts = Object.defineProperty({}, 'passive', {
    get: function() {
      supportsPassive = true;
    }
  });
  window.addEventListener("test", null, opts);
} catch (e) {}

// Use our detect's results. 
// passive applied if supported, capture will be false either way.
elem.addEventListener(
  'touchstart',
  fn,
  supportsPassive ? { passive: true } : false
); 
```

简单来说就是利用`defineProperty`定义属性的`getter`,如果检测到浏览器试图去访问`opts`的`passive`属性，就说明浏览器是支持`passive`的，否则就将`addEventListener`的第三个参数改为false。

## Reference

* [移动Web滚动性能优化: Passive event listeners](https://zhuanlan.zhihu.com/p/24555031)
* [passive 的事件监听器 - 紫云飞 - 博客园](http://www.cnblogs.com/ziyunfei/p/5545439.html)
* [Chrome Platform Status](https://www.chromestatus.com/features/5093566007214080)